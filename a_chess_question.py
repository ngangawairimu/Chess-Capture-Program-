# -*- coding: utf-8 -*-
"""A chess question.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kcfKwhlqLuVphanNiwVDHHylMaQWxbUm
"""

# Function to validate the input format for a piece
def validate_input(piece_type, position):
    # Define valid piece types and board positions
    valid_pieces = ["knight", "pawn"]  # Allowed white pieces
    if piece_type not in valid_pieces:
        return False, "Invalid piece type. Choose 'knight' or 'pawn'."

    # Validate the position format (e.g., "a1", "h8")
    if len(position) != 2 or position[0] not in "abcdefgh" or not position[1].isdigit() or not 1 <= int(position[1]) <= 8:
        return False, "Invalid position. Use coordinates like 'a1', 'h8', etc."

    return True, ""


# Function to get the white piece from the user
def get_white_piece():
    while True:
        white_input = input("Enter the white piece and its position (e.g., 'knight a5'): ")

        try:
            # Split the input into piece type and position
            piece_type, position = white_input.split()
        except ValueError:
            print("Invalid input format. Use 'piece coordinates'.")
            continue

        # Validate the input
        is_valid, error_message = validate_input(piece_type, position)
        if not is_valid:
            print(error_message)
            continue

        return piece_type, position


# Function to get the black pieces from the user
def get_black_pieces():
    black_pieces = []

    print("Enter the black pieces and their positions one by one (e.g., 'pawn b4').")
    print("Type 'done' when you are finished adding black pieces.")

    while len(black_pieces) < 16:
        black_input = input("Add a black piece (or type 'done' to finish): ").strip()

        if black_input.lower() == "done":
            if len(black_pieces) < 1:
                print("You must add at least one black piece.")
                continue
            break

        try:
            # Split the input into piece type and position
            piece_type, position = black_input.split()
        except ValueError:
            print("Invalid input format. Use 'piece coordinates'.")
            continue

        # Validate the input
        is_valid, error_message = validate_input(piece_type, position)
        if not is_valid:
            print(error_message)
            continue

        # Check for duplicate positions
        if position in [pos for _, pos in black_pieces]:
            print("A piece is already at this position. Choose a different one.")
            continue

        # Add the black piece to the list
        black_pieces.append((piece_type, position))
        print(f"Black piece '{piece_type}' at '{position}' added successfully.")

    return black_pieces


# Function to determine which black pieces the white piece can take
def find_capturable_pieces(white_piece, white_position, black_pieces):
    capturable = []

    # Define movement logic for the allowed white pieces
    if white_piece == "knight":
        # Knight moves in an "L" shape
        possible_moves = [
            (2, 1), (2, -1), (-2, 1), (-2, -1),
            (1, 2), (1, -2), (-1, 2), (-1, -2)
        ]
    elif white_piece == "pawn":
        # Pawn can capture diagonally one square
        possible_moves = [(1, 1), (1, -1)]
    else:
        return []  # Unsupported piece

    # Convert the white position into numerical coordinates
    white_col, white_row = ord(white_position[0]) - ord('a'), int(white_position[1])

    # Check which black pieces are in capturable positions
    for black_piece, black_position in black_pieces:
        black_col, black_row = ord(black_position[0]) - ord('a'), int(black_position[1])
        for move in possible_moves:
            if white_col + move[0] == black_col and white_row + move[1] == black_row:
                capturable.append((black_piece, black_position))
                break

    return capturable


# Main program
def main():
    print("Welcome to the Chess Capture Program!")

    # Step 1: Get the white piece
    white_piece, white_position = get_white_piece()
    print(f"\nWhite piece: {white_piece} at {white_position}")

    # Step 2: Get the black pieces
    black_pieces = get_black_pieces()
    print(f"\nBlack pieces: {', '.join([f'{p} at {pos}' for p, pos in black_pieces])}")

    # Step 3: Determine capturable pieces
    capturable_pieces = find_capturable_pieces(white_piece, white_position, black_pieces)

    # Step 4: Display results
    if capturable_pieces:
        print("\nThe white piece can capture the following black pieces:")
        for piece, position in capturable_pieces:
            print(f"- {piece} at {position}")
    else:
        print("\nThe white piece cannot capture any black pieces.")

    print("\nThank you for using the Chess Capture Program!")

# Run the program
if __name__ == "__main__":
    main()